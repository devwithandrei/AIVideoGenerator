'use server';

/**
 * @fileOverview Generates an image from a text prompt using Stable Diffusion XL via Replicate.
 *
 * - generateImageFromText - A function that handles the image generation process.
 * - GenerateImageFromTextInput - The input type for the generateImageFromText function.
 * - GenerateImageFromTextOutput - The return type for the generateImageFromText function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import Replicate from 'replicate';

const GenerateImageFromTextInputSchema = z.object({
  prompt: z.string().describe('The text prompt to generate the image from.'),
  negative_prompt: z.string().optional().describe('Negative prompt to avoid certain elements.'),
  width: z.number().optional().default(1024).describe('Width of the generated image.'),
  height: z.number().optional().default(1024).describe('Height of the generated image.'),
  num_inference_steps: z.number().optional().default(20).describe('Number of inference steps.'),
  guidance_scale: z.number().optional().default(7.5).describe('Guidance scale for generation.'),
});
export type GenerateImageFromTextInput = z.infer<typeof GenerateImageFromTextInputSchema>;

const GenerateImageFromTextOutputSchema = z.object({
  imageDataUri: z.string().describe('The generated image as a data URI.'),
});
export type GenerateImageFromTextOutput = z.infer<typeof GenerateImageFromTextOutputSchema>;

export async function generateImageFromText(input: GenerateImageFromTextInput): Promise<GenerateImageFromTextOutput> {
  return generateImageFromTextFlow(input);
}

const generateImageFromTextFlow = ai.defineFlow(
  {
    name: 'generateImageFromTextFlow',
    inputSchema: GenerateImageFromTextInputSchema,
    outputSchema: GenerateImageFromTextOutputSchema,
  },
  async (input) => {
    try {
      // Initialize Replicate client
      const replicate = new Replicate({
        auth: process.env.REPLICATE_API_TOKEN,
      });

      // Generate image using Stable Diffusion XL
      const output = await replicate.run(
        "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
        {
          input: {
            prompt: input.prompt,
            negative_prompt: input.negative_prompt || "blurry, low quality, distorted, ugly, bad anatomy",
            width: input.width,
            height: input.height,
            num_inference_steps: input.num_inference_steps,
            guidance_scale: input.guidance_scale,
            seed: Math.floor(Math.random() * 1000000), // Random seed for variety
          }
        }
      );

      if (!output || !Array.isArray(output) || output.length === 0) {
        throw new Error('Failed to generate image with Replicate');
      }

      const imageUrl = output[0] as string;
      
      // Download the image and convert to data URI
      const fetch = (await import('node-fetch')).default;
      const imageResponse = await fetch(imageUrl);
      
      if (!imageResponse.ok) {
        throw new Error('Failed to download generated image');
      }

      const buffer = await imageResponse.arrayBuffer();
      const imageBase64 = Buffer.from(buffer).toString('base64');
      const imageDataUri = `data:image/png;base64,${imageBase64}`;

      return { imageDataUri };
    } catch (error) {
      console.error('Image generation failed:', error);
      
      // Fallback: Try using Hugging Face API
      try {
        const hfResponse = await fetch(
          "https://api-inference.huggingface.co/models/runwayml/stable-diffusion-v1-5",
          {
            headers: {
              Authorization: `Bearer ${process.env.HUGGINGFACE_API_TOKEN || 'hf_demo'}`,
              "Content-Type": "application/json",
            },
            method: "POST",
            body: JSON.stringify({
              inputs: input.prompt,
              parameters: {
                negative_prompt: input.negative_prompt || "blurry, low quality, distorted, ugly, bad anatomy",
                width: input.width,
                height: input.height,
                num_inference_steps: input.num_inference_steps,
                guidance_scale: input.guidance_scale,
              }
            }),
          }
        );

        if (!hfResponse.ok) {
          throw new Error('Hugging Face API failed');
        }

        const imageBuffer = await hfResponse.arrayBuffer();
        const imageBase64 = Buffer.from(imageBuffer).toString('base64');
        const imageDataUri = `data:image/png;base64,${imageBase64}`;

        return { imageDataUri };
      } catch (fallbackError) {
        console.error('Fallback image generation also failed:', fallbackError);
        throw new Error('Image generation failed. Please check your API tokens and try again.');
      }
    }
  }
);
